// ============================================
// FILE: games/snake.js
// Generated by LLM, corrected by Claude Code
// Fixes: Collision.check() → Collision.rectRect()
//        food.gol.clear() → food.gol.clearGrid()
// ============================================

// ===== IMPORTS (Standard - DO NOT MODIFY) =====
import { GoLEngine } from '../src/core/GoLEngine.js'
import { SimpleGradientRenderer } from '../src/rendering/SimpleGradientRenderer.js'
import { GRADIENT_PRESETS } from '../src/utils/GradientPresets.js'
import { Collision } from '../src/utils/Collision.js'
import { Patterns } from '../src/utils/Patterns.js'
import { seedRadialDensity, applyLifeForce, maintainDensity } from '../src/utils/GoLHelpers.js'
import { updateParticles, renderParticles } from '../src/utils/ParticleHelpers.js'
import { renderGameUI, renderGameOver } from '../src/utils/UIHelpers.js'

// ===== CONFIG =====
const CONFIG = {
  width: 800,
  height: 600,
  ui: {
    backgroundColor: '#FFFFFF',
    textColor: '#5f6368',
    accentColor: '#1a73e8',
    font: 'Google Sans, Arial, sans-serif',
    fontSize: 16
  },
  // --- Game-specific config ---
  SEGMENT_SIZE: 60,
  FOOD_SIZE: 60,
  SNAKE_SPEED: 4, // pixels per frame
  SNAKE_START_LENGTH: 3
}

// ===== STATE =====
const state = {
  score: 0,
  lives: 1, // ALWAYS 1
  phase: 'PLAYING', // PLAYING | GAMEOVER
  frameCount: 0,
  snakeLength: 0 // Will be set in initGame
}

// ===== ENTITIES =====
let snake = null
let food = null
let particles = []
let maskedRenderer = null

// ===== HELPER VARS =====
// Calculate how many path points to store per segment
const POINTS_PER_SEGMENT = CONFIG.SEGMENT_SIZE / CONFIG.SNAKE_SPEED

// ===== SETUP =====
function setup() {
  createCanvas(CONFIG.width, CONFIG.height)
  frameRate(60)
  // This is the ONLY place 'this' is used
  maskedRenderer = new SimpleGradientRenderer(this)
  initGame()
}

// ===== UPDATE LOOP =====
function draw() {
  state.frameCount++
  background(CONFIG.ui.backgroundColor)

  if (state.phase === 'PLAYING') {
    updateGame()
  } else if (state.phase === 'GAMEOVER') {
    // Continue updating explosion particles
    particles = updateParticles(particles, state.frameCount)
  }

  renderGame()
  renderUI()
  maskedRenderer.updateAnimation()

  if (state.phase === 'GAMEOVER') {
    renderGameOver(width, height, state.score)
  }
}

// ===== GAME LOGIC =====

/**
 * Initializes or resets the game state.
 */
function initGame() {
  state.score = 0
  state.phase = 'PLAYING'
  state.snakeLength = CONFIG.SNAKE_START_LENGTH
  particles = []

  snake = {
    head: createSnakeSegment(true), // true = isHead
    bodyGols: [], // Array of GoL engines for body segments
    path: [], // Array of {x, y} points for the head's path
    vx: CONFIG.SNAKE_SPEED,
    vy: 0
  }

  snake.head.x = CONFIG.width / 2
  snake.head.y = CONFIG.height / 2

  // Pre-populate body GoL engines
  for (let i = 0; i < CONFIG.SNAKE_START_LENGTH - 1; i++) {
    snake.bodyGols.push(createSnakeSegment(false).gol) // false = isBody
  }

  // Pre-populate the path so the snake has a body at the start
  const initialPathLength = state.snakeLength * POINTS_PER_SEGMENT
  for (let i = 0; i < initialPathLength; i++) {
    snake.path.push({ x: snake.head.x, y: snake.head.y })
  }

  food = createFood()
  spawnFood()
}

/**
 * Main update function called every frame during 'PLAYING' phase.
 */
function updateGame() {
  updateSnake()
  updateFood()
  checkCollisions()
}

/**
 * Updates the snake's position, path, and GoL engines.
 */
function updateSnake() {
  // Move head
  snake.head.x += snake.vx
  snake.head.y += snake.vy

  // Add new head position to the front of the path
  snake.path.unshift({ x: snake.head.x, y: snake.head.y })

  // Trim the path to the required length
  const totalPointsNeeded = state.snakeLength * POINTS_PER_SEGMENT
  while (snake.path.length > totalPointsNeeded && snake.path.length > 0) {
    snake.path.pop()
  }

  // Update GoL engines
  // Head (Modified GoL)
  snake.head.gol.updateThrottled(state.frameCount)
  applyLifeForce(snake.head)

  // Body (Visual Only)
  if (state.frameCount % 5 === 0) { // Throttle density check
    snake.bodyGols.forEach(gol => {
      // maintainDensity expects an entity, so we wrap the gol
      maintainDensity({ gol: gol }, 0.8)
    })
  }
}

/**
 * Updates the food's GoL engine (Pulsar).
 */
function updateFood() {
  food.gol.updateThrottled(state.frameCount)
}

/**
 * Checks for all game-ending or scoring collisions.
 */
function checkCollisions() {
  const headRect = {
    x: snake.head.x,
    y: snake.head.y,
    width: snake.head.width,
    height: snake.head.height
  }

  // 1. Wall Collision
  if (headRect.x < 0 || headRect.x + headRect.width > CONFIG.width ||
      headRect.y < 0 || headRect.y + headRect.height > CONFIG.height) {
    triggerGameOver()
    return
  }

  // 2. Self Collision
  // Check head against body segments (skip the neck)
  for (let i = 1; i < state.snakeLength - 1; i++) {
    const pointIndex = (i + 1) * POINTS_PER_SEGMENT
    if (pointIndex >= snake.path.length) break // Path not long enough

    const pos = snake.path[pointIndex]
    const segRect = {
      x: pos.x,
      y: pos.y,
      width: CONFIG.SEGMENT_SIZE,
      height: CONFIG.SEGMENT_SIZE
    }

    // Skip the first few segments to avoid "neck" collision
    // FIX: Use Collision.rectRect() instead of Collision.check()
    if (i > 3 && Collision.rectRect(
      headRect.x, headRect.y, headRect.width, headRect.height,
      segRect.x, segRect.y, segRect.width, segRect.height
    )) {
      triggerGameOver()
      return
    }
  }

  // 3. Food Collision
  const foodRect = {
    x: food.x,
    y: food.y,
    width: food.width,
    height: food.height
  }

  // FIX: Use Collision.rectRect() instead of Collision.check()
  if (Collision.rectRect(
    headRect.x, headRect.y, headRect.width, headRect.height,
    foodRect.x, foodRect.y, foodRect.width, foodRect.height
  )) {
    // Eat food
    state.score += 10
    state.snakeLength++
    // Add a new GoL engine for the new body part
    snake.bodyGols.push(createSnakeSegment(false).gol)
    spawnFood()
  }
}

/**
 * Sets game phase to GAMEOVER and spawns an explosion.
 */
function triggerGameOver() {
  state.phase = 'GAMEOVER'
  spawnExplosion(snake.head.x + snake.head.width / 2, snake.head.y + snake.head.height / 2)
}

// ===== ENTITY CREATION =====

/**
 * Creates a new snake segment (head or body).
 * @param {boolean} isHead - True for head (Modified GoL), false for body (Visual Only)
 * @returns {object} A snake segment entity
 */
function createSnakeSegment(isHead) {
  const segment = {
    x: 0,
    y: 0,
    width: CONFIG.SEGMENT_SIZE,
    height: CONFIG.SEGMENT_SIZE,
    cellSize: 10,
    gradient: GRADIENT_PRESETS.PLAYER
  }

  if (isHead) {
    // Head: 60x60, 12fps, Modified GoL
    segment.gol = new GoLEngine(6, 6, 12)
    seedRadialDensity(segment.gol, 0.85, 0.0)
  } else {
    // Body: 60x60, 0fps, Visual Only
    segment.gol = new GoLEngine(6, 6, 0)
    seedRadialDensity(segment.gol, 0.8, 0.0) // Slightly denser
  }

  return segment
}

/**
 * Creates the food entity.
 * @returns {object} The food entity
 */
function createFood() {
  const foodEntity = {
    x: 0,
    y: 0,
    width: CONFIG.FOOD_SIZE,
    height: CONFIG.FOOD_SIZE,
    cellSize: 10,
    // Per request, food is yellow (BULLET preset)
    gradient: GRADIENT_PRESETS.BULLET,
    // Food: 60x60, 15fps, Pure GoL
    gol: new GoLEngine(6, 6, 15)
  }

  // Use the Pulsar pattern
  foodEntity.gol.setPattern(Patterns.PULSAR, 0, 0)
  return foodEntity
}

/**
 * Moves the food to a new random location.
 */
function spawnFood() {
  const padding = CONFIG.FOOD_SIZE
  food.x = random(padding, CONFIG.width - padding)
  food.y = random(padding, CONFIG.height - padding)

  // Ensure the pattern is re-set in case it died out
  // FIX: Use clearGrid() instead of clear()
  food.gol.clearGrid()
  food.gol.setPattern(Patterns.PULSAR, 0, 0)
}

/**
 * Spawns explosion particles at a location.
 */
function spawnExplosion(x, y) {
  // 6 particles, 30x30, 30fps
  for (let i = 0; i < 6; i++) {
    const particle = {
      x: x + random(-10, 10),
      y: y + random(-10, 10),
      vx: random(-3, 3),
      vy: random(-3, 3),
      alpha: 255,
      width: 30,
      height: 30,
      cellSize: 10,
      gol: new GoLEngine(3, 3, 30), // Fast evolution
      gradient: GRADIENT_PRESETS.EXPLOSION,
      dead: false
    }

    seedRadialDensity(particle.gol, 0.8, 0.0)
    particles.push(particle)
  }
}

// ===== RENDERING =====

/**
 * Renders all game entities (snake, food, particles).
 */
function renderGame() {
  // Render food
  maskedRenderer.renderMaskedGrid(
    food.gol,
    food.x,
    food.y,
    food.cellSize,
    food.gradient
  )

  // Render snake (ONLY if not game over)
  if (state.phase !== 'GAMEOVER') {
    // Render Head
    maskedRenderer.renderMaskedGrid(
      snake.head.gol,
      snake.head.x,
      snake.head.y,
      snake.head.cellSize,
      snake.head.gradient
    )

    // Render Body Segments
    for (let i = 0; i < state.snakeLength - 1; i++) {
      const pointIndex = (i + 1) * POINTS_PER_SEGMENT
      if (pointIndex >= snake.path.length) break // Path not long enough yet

      const pos = snake.path[pointIndex]
      const gol = snake.bodyGols[i]

      if (gol) {
        maskedRenderer.renderMaskedGrid(
          gol,
          pos.x,
          pos.y,
          snake.head.cellSize,
          snake.head.gradient
        )
      }
    }
  }

  // Render particles (explosions)
  renderParticles(particles, maskedRenderer)
}

/**
 * Renders the UI (score, length, controls).
 */
function renderUI() {
  const controls = ['← → ↑ ↓ or WASD: Move', 'SPACE: Restart']
  // Use the standard helper for controls
  renderGameUI(CONFIG, state, controls)

  // Manually render "SCORE: X | LENGTH: Y" to meet spec
  // (The default helper only shows SCORE and LIVES)
  fill(CONFIG.ui.textColor)
  noStroke()
  textFont(CONFIG.ui.font)
  textSize(CONFIG.ui.fontSize)
  textAlign(LEFT, TOP)

  const uiString = `SCORE: ${state.score} | LENGTH: ${state.snakeLength}`
  text(uiString, 20, 20)
}

// ===== CONTROLS =====

function keyPressed() {
  // Restart on SPACE during GAMEOVER
  if (state.phase === 'GAMEOVER' && (key === ' ' || keyCode === 32)) {
    initGame()
    return
  }

  if (state.phase !== 'PLAYING') return

  // Handle direction changes, preventing 180-degree turns
  if ((keyCode === UP_ARROW || key === 'w') && snake.vy === 0) {
    snake.vx = 0
    snake.vy = -CONFIG.SNAKE_SPEED
  } else if ((keyCode === DOWN_ARROW || key === 's') && snake.vy === 0) {
    snake.vx = 0
    snake.vy = CONFIG.SNAKE_SPEED
  } else if ((keyCode === LEFT_ARROW || key === 'a') && snake.vx === 0) {
    snake.vx = -CONFIG.SNAKE_SPEED
    snake.vy = 0
  } else if ((keyCode === RIGHT_ARROW || key === 'd') && snake.vx === 0) {
    snake.vx = CONFIG.SNAKE_SPEED
    snake.vy = 0
  }
}

// ===== EXPORTS =====
window.setup = setup
window.draw = draw
window.keyPressed = keyPressed
